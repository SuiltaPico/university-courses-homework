# 排序算法
## 桶排序
### 代码
```cpp
#include <cstdio>

using namespace std;

// 希尔排序，桶排序的桶内排序使用的排序算法，不做解释
template <typename T>
void ShellSort(T *arr, size_t len)
{
    for (size_t gap = len / 2; gap >= 1; gap /= 2)
    {
        for (size_t i = gap; i < len; i++)
        {
            for (long long j = i - gap; j >= 0 && arr[j] > arr[gap + j]; j -= gap)
            {
                T temp = arr[j];
                arr[j] = arr[gap + j];
                arr[gap + j] = temp;
            }
        }
    }
}

void bucketSort(int *arr, size_t arr_len, size_t bucket_num = 10)
{
    // 数组小于二则直接返回
    if (arr_len < 2)
        return;

    // 记录最大值与最小值，先假设为第0个元素
    int min, max;
    min = max = arr[0];

    // 一个个遍历找到最大最小值
    for (size_t i = 1; i < arr_len; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }

    /// 如果范围很小，则转换为计数排序，减少桶的数量
    if (max - min + 1 < (int)bucket_num)
        bucket_num = max - min + 1;

    /// 桶数组的实际大小
    const size_t buckets_size = bucket_num * arr_len; // 这里采用一维数组以模拟二维数组，为了简化流程，每个桶长度设为 arr_len 以应付单个桶装满的情况

    /// 桶数组
    int *buckets = new int[buckets_size]();
    /// 桶的长度的记录表
    size_t *buckets_len = new size_t[bucket_num]();
    
    /* 桶的二维数组映射到一维数组的函数：
        buckets_item(行, 列) = buckets[行*单个桶长度+列]
    */

    // 把每个数字放到桶里
    for (size_t i = 0; i < arr_len; i++)
    {
        /// 对应的桶的位置，计算方法为 位置 = (arr[i] - min) / (max - min + 1) * 桶的个数
        size_t bucket_index = double(arr[i] - min) / double(max - min + 1) * bucket_num; // 找到每个数字对应的桶的位置

        buckets[bucket_index * arr_len + buckets_len[bucket_index]] = arr[i]; // 把这个数放进桶里
        buckets_len[bucket_index]++;                                          // 长度的记录表记录长度增加
    }

    // 对每个桶进行排序
    for (size_t i = 0; i < bucket_num; i++)
        ShellSort((int *)buckets + i * arr_len, buckets_len[i]); // 这里使用了指针运算，将原来的指针进行向后偏移就是对应的桶了

    // 然后把桶里面排序好的数据放到 arr 上
    
    size_t arr_index = 0;

    for (size_t i = 0; i < bucket_num; i++)
    {
        for (size_t j = 0; j < buckets_len[i]; j++)
        {
            arr[arr_index] = buckets[i * arr_len + j];
            arr_index++;
        }
    }
}

int main()
{
    int arr[] = {71, 35, 52, 87, 92, 72, 58, 46, 70, 78, 74, 78};
    bucketSort(arr, sizeof(arr) / sizeof(int), 10);
    for (size_t i = 0; i < sizeof(arr) / sizeof(int); i++)
        printf("%4d ", arr[i]);
    return 0;
}
```
## 计数排序
### 代码
```cpp
#include <cstdio>

using namespace std;

void countSort(int *arr, size_t arr_len)
{
    if (arr_len < 2)
        return;

    int min, max;
    min = max = arr[0];

    for (size_t i = 1; i < arr_len; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }

    int *counter = new int[max - min + 1]();

    for (size_t i = 0; i < arr_len; i++)
        counter[arr[i] - min]++;

    int arr_index = 0;
    for (size_t i = 0; i <= (size_t)max - min; i++)
    {
        for (size_t j = 0; j < (size_t)counter[i]; j++)
        {
            arr[arr_index] = i + min;
            arr_index++;
        }
    }
}

int main()
{
    int arr[] = {10, 2, 5, 2, 3, 5, 1, 2, 3, 7, 4, 0};
    countSort(arr, sizeof(arr) / sizeof(int));
    for (size_t i = 0; i < sizeof(arr) / sizeof(int); i++)
        printf("%4d ", arr[i]);
    return 0;
}
```

## 基数排序
### 代码
```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

bool radixSort(int *arr, size_t arr_len)
{
    vector<int> stacks[10];

    for (size_t i = 0; i < sizeof(stacks) / sizeof(vector<int>); i++)
        stacks[i] = vector<int>();

    int
        max = arr[0],
        max_power_of_10 = 0;

    for (size_t i = 1; i < arr_len; i++)
    {
        if (arr[i] > max)
            max = arr[i];
    }

    while (max / (int)pow(10, max_power_of_10) != 0)
    {
        max_power_of_10++;
    }

    for (int power_of_10 = 0; power_of_10 < max_power_of_10; power_of_10++)
    {
        for (size_t i = 0; i < arr_len; i++)
            stacks[arr[i] / (int)pow(10, power_of_10) % 10].push_back(arr[i]);

        int arr_index = 0;
        for (size_t i = 0; i < 10; i++)
        {
            for (size_t j = 0; j < stacks[i].size(); j++)
            {
                arr[arr_index] = stacks[i].at(j);
                arr_index++;
            }
            stacks[i].clear();
        }
    }
}

int main()
{
    int arr[] = {10, 12, 85, 12, 33, 155, 1, 22, 43, 27, 34, 0};
    radixSort(arr, sizeof(arr) / sizeof(int));
    for (size_t i = 0; i < sizeof(arr) / sizeof(int); i++)
        printf("%4d ", arr[i]);
    return 0;
}
```
